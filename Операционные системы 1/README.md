# Операционные системы 1
1. Какой системный вызов делает команда cd?
    <br/>
    В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это `shell builtin`, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте.
    <br/>
    ![1](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%201/1.jpg)
    <br/>
    `cd` делает системный вызов `chdir()`
2. Попробуйте использовать команду `file` на объекты разных типов в файловой системе. Используя `strace` выясните, где находится база данных `file`, на основании которой она делает свои догадки.
    <br/>
    ![2](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%201/2.jpg)
    <br/>
    Информация, идентифицирующая эти файлы, считывается из скомпилированного файла - `/usr/share/file/magic.mgc`. Так же эту информацию можно найти в `man file` на строке 36.
3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
    <br/>
    ОБНУЛИТЬ ФАЙЛ
    <br/>
    В этом случае сам файл останется в файловой системе пока процесс не завершится, но размер файла будет 0 байт и место на диске высвободится
    <br/>
    ```bash
    sudo truncate -s 0 /proc/1366/fd/4
    ```
    <br/>
4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
    <br/>
    Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
    <br/>
5. В iovisor BCC есть утилита `opensnoop`:
    <br/>
    ![3](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%201/3.jpg)
    <br/>
6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.
    <br/>
    Команда `uname -a` использует системный вызов `uname()` например: 
    <br/>
    ```bash
    uname({sysname="Linux", nodename="ubuntu-20", ...}) = 0
    ```
    <br/>
    Цитата их man: `Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.`
    <br/>
7.  Чем отличается последовательность команд через `;` и через `&& `в bash? Чем отличается последовательность команд через `;` и через `&&` в bash?
    <br/>
    - С использованем `;` обе команды отработают в любом случае.
    - С использованием && вторая команда отработает только при успешном результате первой.
    Пример:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    <br/>
    В первом случае выполняется обе команды внезависимости друг от друга, тоесть первая команда не выполнилась, а вторая успешно выполнилась и вывела результат выполнения
    <br/>
    Во втором случае из за  того что первая команда не выполнилась, `&&` предусматривает собой успешное выполнение первой команды, а потом второй. Из этого можно сделать вывод, что первая команда успешно не выполнилась, слдественно не выполнилась и вторая команда, поэтому в терминале нечего не вывелось.
    <br/>
    - С применением set -e скрипт/оболочка завершит работу при ненулевом коде возврата команды. В принципе, конструкция с && работать будет, но она необязательна, т.к. при другом условии оболочка просто завершится.
    <br/>
8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?
    <br/>
    - параметр `-e`, если его указать то скрипт немедленно завершит работу, если любая команда выйдет с ошибкой;
    - параметр `-o pipefail`, параметр `-e` не идеален. Bash возвращает только код ошибки последней команды в пайпе (конвейере). И параметр `-e` проверяет только его. Если нужно убедиться, что все команды в пайпах завершились успешно, нужно использовать `-o pipefail`
    - параметр `-u`, благодоря данному параметру оболочка проверяет инициализацую в скрипте. Если переменной не будет, скрипт немедленно завершится;
    - параметр `-x`, он нужен для отладки. С помощью него bash печатает в стандартный вывод все команды перед их исполнением.
    <br/>
    Данный режим обеспечивает прекращение работы сценария в случае ошибки и детализацию логирования.
9. Используя `-o sta`t для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
    <br/>
    ![4](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%201/4.jpg)
    <br/>
    Дополнительные параметры:
    * < high-priority (not nice to other users)
    * N low-priority (nice to other users)
    * L has pages locked into memory (for real-time and custom IO)
    * s is a session leader
    * l is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
    * + is in the foreground process group
    Данная информация находится в `man`:
    ![5](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%201/5.jpg)



# Операционные системы - 2
1. На лекции мы познакомились с `node_exporter`. В демонстрации его исполняемый файл запускался в background. Этого достаточно для демо, но не для настоящей production-системы, где процессы должны находиться под внешним управлением. Используя знания из лекции по `systed`, создайте самостоятельно простой unit-файл для node_exporter:
поместите его в автозагрузку, предусмотрите возможность добавления опций к запускаемому процессу через внешний файл (посмотрите, например, на `systemctl cat cron`), удостоверьтесь, что с помощью systemctl процесс корректно стартует, завершается, а после перезагрузки автоматически поднимается.
    <br/>
    Запуск node_exporter
    <br/>
    ![1](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/1.png)
    <br/>
    Помещение в автозагрузку
    <br/>
    ![1.2](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/1.2.png)
    <br/>
    Создан unit-файл для Node_Exporter предусматривающий добавление опций к запускаемому процессу через внешний файл
    <br/>
    ![1.3](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/1.3.png)
    <br/>
    При помощи `systemctl` процесс корректно запускается, останавливается, после перезагрузки автоматически поднимается.
    <br/>
    ![1.5](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/1.5.png)
    <br/>
    ![1.4](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/1.5.png)
    <br/>
    ![1.6](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/1.6.png)
2. Ознакомьтесь с опциями node_exporter и выводом /metrics по-умолчанию. Приведите несколько опций, которые вы бы выбрали для базового мониторинга хоста по CPU, памяти, диску и сети.
    <br/>
    ```bash
    collector.cpu
    collector.cpufreq
    collector.diskstats
    collector.meminfo
    collector.netstat 
    ```
    <br/>
3. Установите в свою виртуальную машину Netdata. Воспользуйтесь готовыми пакетами для установки (`sudo apt install -y netdata`).
После успешной установки: в конфигурационном файле `/etc/netdata/netdata.con`f в секции [web] замените значение с `localhost` на `bind to = 0.0.0.0`, добавьте в `Vagrantfile` проброс порта Netdata на свой локальный компьютер и сделайте `vagrant reload`: `config.vm.network "forwarded_port"`, `guest: 19999, host: 19999`
После успешной перезагрузки в браузере на своем ПК (не в виртуальной машине) вы должны суметь зайти на `localhost:19999`. Ознакомьтесь с метриками, которые по умолчанию собираются Netdata и с комментариями, которые даны к этим метрика.
    <br/>
    ![3](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/2.png)
    <br/>
    ![3.1](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/2.1.png)
    <br/>
4. Можно ли по выводу `dmesg` понять, осознает ли ОС, что загружена не на настоящем оборудовании, а на системе виртуализации?
    <br/>
    - Да, можно
    ```bash
    Hypervisor detected: KVM
    systemd[1]: Detected virtualization oracle.
    CPU MTRRs all blank - virtualized system.
    ```
5. Как настроен `sysctl fs.nr_open` на системе по-умолчанию? Определите, что означает этот параметр. Какой другой существующий лимит не позволит достичь такого числа (`ulimit --help`)?
    <br/>
    ![5](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/5.png)
    <br/>
    Существует два типа ограничений: «жесткое ограничение» и «мягкое ограничение».
    <br/>
    *  «Жесткое ограничение» для открытых файлов статически заданное значение, и может быть изменен
    только «корневым» пользователем Linux;
    *  «Мягкое ограничение» — это ограничение, которое может изменяться процессами динамически,
    т. е. Во время выполнения, если процессу требуется больше открытых файлов, чем разрешено мягким пределом.
    <br/>
    Тем самым:
    <br/>
    - `fs.nr_open` обозначает максимальное количество файловых дескрипторов, которые может использовать процесс. Значение по умолчанию — 1024*1024 (1048576)
    <br/>
    - `ulimit -Hn` получает значение жёсткого ограничения на число одновременно открытых файлов, данное ограничение не позволит достичь числа `fs.nr_open`
    <br/>
6. Запустите любой долгоживущий процесс (не ls, который отработает мгновенно, а, например, sleep 1h) в отдельном неймспейсе процессов; покажите, что ваш процесс работает под PID 1 через nsenter. Для простоты работайте в данном задании под root (sudo -i). Под обычным пользователем требуются дополнительные опции (--map-root-user) и т.д.
    <br/>
    Проделываем все действия под `root` пользователем
    <br/>
    Запускаем sleep через unshare:
    <br/>
    ![6](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/6.png)
    <br/>
    Заходим в процесс:
    <br/>
    ![6.1](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/6.1.png)
    <br/>
7. Найдите информацию о том, что такое `:(){ :|:& };:`. Запустите эту команду в своей виртуальной машине `Vagrant с Ubuntu 20.04` (это важно, поведение в других ОС не проверялось). Некоторое время все будет "плохо", после чего (минуты) – ОС должна стабилизироваться. Вызов `dmesg` расскажет, какой механизм помог автоматической стабилизации. Как настроен этот механизм по-умолчанию, и как изменить число процессов, которое можно создать в сессии?
    <br/>
    `:()` означает, что вы определяете функцию под названием :
    <br/>
    `{:|: &}` означает запустить функцию :и :снова отправить ее вывод в функцию и запустить ее в фоновом режиме.
    <br/>
    Это `;` разделитель команд.
    <br/>
    `:` запускает функцию в первый раз.
    <br/>
    По сути, вы создаете функцию, которая вызывает себя дважды при каждом вызове и не имеет возможности завершить себя. Он будет удваиваться, пока у вас не закончатся системные ресурсы.
    <br/>
    При запуске данной функции был перегружен cpu это можно просмотреть на сайте:
    <br/>
    ![7.1](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/7.1.png)
    <br/>
    При перегрузке сработал pid controller:
    <br/>
    ![7](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/7.png)
    <br/>
    Для того чтобы ограничить число процессов нужно использовать команду `ulimit -u <число>`
    <br/>
    ![7.2](/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D1%8B%D0%B5%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B%202/7.2.png)